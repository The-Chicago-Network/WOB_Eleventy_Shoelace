{"version":3,"sources":["../../src/types/index.ts"],"sourcesContent":["import type { Language, TokenizerConfig } from \"../tokenizer/index.js\";\nimport type { Hooks } from \"../methods/hooks.js\";\nimport type { RadixNode } from \"../trees/radix/node.js\";\nimport type { AVLNode } from \"../trees/avl/node.js\";\n\nexport * from \"./filters.js\";\nexport * from \"./facets.js\";\n\nexport type TokenScore = [string, number];\nexport type Nullable<T> = T | null;\n\nexport type IIntersectTokenScores = (arrays: TokenScore[][]) => TokenScore[];\n\nexport type ResolveSchema<T extends PropertiesSchema> = {\n  [P in keyof T]: ResolveTypes<T[P]>;\n};\n\nexport type SearchProperties<\n  TSchema extends PropertiesSchema,\n  TKey extends keyof TSchema = keyof TSchema,\n> = TKey extends string\n  ? TSchema[TKey] extends PropertiesSchema\n    ? `${TKey}.${SearchProperties<TSchema[TKey]>}`\n    : TKey\n  : never;\n\n\nexport type PropertyType = \"string\" | \"number\" | \"boolean\";\n\nexport type PropertiesSchema = {\n  [key: string]: PropertyType | PropertiesSchema;\n};\n\nexport type AlgorithmsConfig = {\n  intersectTokenScores: IIntersectTokenScores;\n};\n\nexport type PropertiesBoost<S extends PropertiesSchema> = {\n  [P in keyof S]?: number;\n};\n\nexport type ElaspedConfig = {\n  format?: \"human\" | \"raw\",\n}\n\nexport type Configuration<S extends PropertiesSchema> = {\n  /**\n   * The structure of the document to be inserted into the database.\n   */\n  schema: S;\n  /**\n   * The default language analyzer to use.\n   */\n  defaultLanguage?: Language;\n  edge?: boolean;\n  hooks?: Hooks;\n  components?: Components;\n};\n\nexport type Data<S extends PropertiesSchema> = {\n  docs: Record<string, ResolveSchema<S> | undefined>;\n  defaultLanguage: Language;\n  index: Index;\n  schema: S;\n  frequencies: FrequencyMap;\n  tokenOccurrencies: TokenOccurrency;\n  avgFieldLength: Record<string, number>;\n  fieldLengths: Record<string, Record<string, number>>;\n};\n\nexport type Components = {\n  elapsed?: ElaspedConfig;\n  tokenizer?: TokenizerConfig;\n  algorithms?: AlgorithmsConfig;\n};\n\nexport interface Lyra<S extends PropertiesSchema> extends Data<S> {\n  defaultLanguage: Language;\n  schema: S;\n  edge: boolean;\n  hooks: Hooks;\n  components?: Components;\n  frequencies: FrequencyMap;\n  docsCount: number;\n  avgFieldLength: Record<string, number>;\n  fieldLengths: Record<string, Record<string, number>>;\n}\n\nexport type BM25OptionalParams = {\n  k?: number;\n  b?: number;\n  d?: number;\n};\n\nexport type BM25Params = {\n  k: number;\n  b: number;\n  d: number;\n};\n\nexport type TokenMap = Record<string, TokenScore[]>;\n\ntype ResolveTypes<TType> = TType extends \"string\"\n  ? string\n  : TType extends \"boolean\"\n  ? boolean\n  : TType extends \"number\"\n  ? number\n  : TType extends PropertiesSchema\n  ? { [P in keyof TType]: ResolveTypes<TType[P]> }\n  : never;\n\ntype Index = Record<string, RadixNode | AVLNode<number, string[]>>;\n\ntype FrequencyMap = {\n  [property: string]: {\n    [documentID: string]: {\n      [token: string]: number;\n    };\n  };\n};\n\ntype TokenOccurrency = {\n  [property: string]: {\n    [token: string]: number;\n  };\n};\n"],"names":[],"mappings":"AAKA,cAAc,eAAe;AAC7B,cAAc,cAAc"}