{"version":3,"sources":["../src/facets.ts"],"sourcesContent":["import type { FacetSorting, FacetsSearch, PropertiesSchema, ResolveSchema, TokenScore } from \"./types/index.js\";\nimport { getNested } from './utils.js';\n\nexport type FacetReturningValue = {\n  [key: string]: {\n    count: number;\n    values: {\n      [key: string]: number;\n    }\n  }\n}\n\nexport function getFacets<S extends PropertiesSchema>(schema: PropertiesSchema, docs: Record<string, ResolveSchema<S> | undefined>, results: TokenScore[], facetsConfig: FacetsSearch<S>): FacetReturningValue {\n  const facets: FacetReturningValue = {};\n  const allIDs = results.map(([id]) => id);\n  const allDocs = allIDs.map((id) => docs[id]);\n  const facetKeys = Object.keys(facetsConfig);\n\n  for (const facet of facetKeys) {\n    const facetType = getFacetType(schema, facet);\n    let values = {};\n\n    // Hack to guarantee the same order of ranges as specified by the user\n    if (facetType === \"number\") {\n      const { ranges } = (facetsConfig as any)[facet];\n      const tmp = [];\n      for (const range of ranges) {\n        tmp.push([`${range.from}-${range.to}`, 0]);\n      }\n      values = Object.fromEntries(tmp as any);\n    }\n\n    facets[facet] = {\n      count: 0,\n      values,\n    };\n  }\n\n  const allDocsLength = allDocs.length;\n  for (let i = 0; i < allDocsLength; i++) {\n    const doc = allDocs[i];\n\n    for (const facet of facetKeys) {\n      const facetValue = facet.includes('.')\n        ? getNested<string>(doc!, facet)!\n        : doc![facet] as number | boolean;\n\n      // String based facets\n      if (typeof facetValue === \"string\") {\n        if (facets[facet].values[facetValue] === undefined) {\n          facets[facet].values[facetValue] = 1;\n        } else {\n          facets[facet].values[facetValue]++;\n        }\n\n      // Boolean facets\n      } else if (typeof facetValue === \"boolean\") {\n        if (facets[facet].values[facetValue.toString()] === undefined) {\n          facets[facet].values[facetValue.toString()] = 1;\n        } else {\n          facets[facet].values[facetValue.toString()]++;\n        }\n      }\n\n      // Range facets based on numbers\n      else if (typeof facetValue === \"number\") {\n        for (const range of (facetsConfig as any)[facet].ranges) {\n          if (facetValue >= range.from && facetValue <= range.to) {\n            if (facets[facet].values[`${range.from}-${range.to}`] === undefined) {\n              facets[facet].values[`${range.from}-${range.to}`] = 1;\n            } else {\n              facets[facet].values[`${range.from}-${range.to}`]++;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  for (const facet of facetKeys) {\n    const facetType = getFacetType(schema, facet);\n\n    // Count the number of values for each facet\n    facets[facet].count = Object.keys(facets[facet].values).length;\n\n    // Sort only string-based facets\n    if (facetType === \"string\") {\n      facets[facet].values = Object.fromEntries(\n        Object.entries(facets[facet].values)\n          .sort((a, b) => sortingPredicate((facetsConfig as any)[facet].sort, a, b))\n          .slice((facetsConfig as any)[facet].offset ?? 0, (facetsConfig as any)[facet].limit ?? 10),\n      )\n    }\n  }\n\n  return facets;\n}\n\nconst facetTypeCache = new Map<string, string>();\n\nfunction getFacetType(schema: PropertiesSchema, facet: string) {\n  if (facetTypeCache.has(facet)) {\n    return facetTypeCache.get(facet)!;\n  }\n\n  const facetType = getNested<string>(schema, facet)!;\n  facetTypeCache.set(facet, facetType);\n  return facetType;\n}\n\nfunction sortingPredicate(order: FacetSorting = \"desc\", a: [string, number], b: [string, number]) {\n  if (order.toLowerCase() === \"asc\") {\n    return a[1] - b[1];\n  } else {\n    return b[1] - a[1];\n  }\n}"],"names":["getNested","getFacets","schema","docs","results","facetsConfig","facets","allIDs","map","id","allDocs","facetKeys","Object","keys","facet","facetType","getFacetType","values","ranges","tmp","range","push","from","to","fromEntries","count","allDocsLength","length","i","doc","facetValue","includes","undefined","toString","entries","sort","a","b","sortingPredicate","slice","offset","limit","facetTypeCache","Map","has","get","set","order","toLowerCase"],"mappings":"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"}