import { createAVLNode } from "./node.js";
import { BALANCE_STATE, getBalanceFactor, rotateLeft, rotateRight, findMin, getHeight } from "./utils.js";
export function create(key, value) {
    return createAVLNode(key, value);
}
export function insert(node, key, value) {
    if (!node) {
        return create(key, value);
    }
    if (key < node.key) {
        node.left = insert(node.left, key, value);
    } else if (key > node.key) {
        node.right = insert(node.right, key, value);
    } else {
        node.value = node.value.concat(value);
        return node;
    }
    const balanceFactor = getBalanceFactor(node);
    if (balanceFactor === BALANCE_STATE.UNBALANCED_LEFT) {
        if (key < node.left.key) {
            node = rotateRight(node);
        } else {
            node.left = rotateLeft(node.left);
            node = rotateRight(node);
        }
    }
    if (balanceFactor === BALANCE_STATE.UNBALANCED_RIGHT) {
        if (key > node.right.key) {
            node = rotateLeft(node);
        } else {
            node.right = rotateRight(node.right);
            node = rotateLeft(node);
        }
    }
    return node;
}
export function find(node, key) {
    if (!node) {
        return null;
    }
    if (node.key === key) {
        return node.value;
    }
    if (key < node.key) {
        return node.left ? find(node.left, key) : null;
    }
    return node.right ? find(node.right, key) : null;
}
export function getNodeByKey(node, key) {
    if (!node) {
        return null;
    }
    if (node.key === key) {
        return node;
    }
    if (key < node.key) {
        return node.left ? getNodeByKey(node.left, key) : null;
    }
    return node.right ? getNodeByKey(node.right, key) : null;
}
export function remove(node, key) {
    if (!node) {
        return null;
    }
    if (key < node.key) {
        node.left = remove(node.left, key);
    } else if (key > node.key) {
        node.right = remove(node.right, key);
    } else {
        if (!node.left && !node.right) {
            return null;
        }
        if (!node.left) {
            return node.right;
        }
        if (!node.right) {
            return node.left;
        }
        const temp = findMin(node.right);
        node.key = temp.key;
        node.right = remove(node.right, temp.key);
    }
    const balanceFactor = getBalanceFactor(node);
    const leftNode = node.left;
    const rightNode = node.right;
    if (balanceFactor === BALANCE_STATE.UNBALANCED_LEFT) {
        if (getBalanceFactor(leftNode) === BALANCE_STATE.BALANCED || getBalanceFactor(leftNode) === BALANCE_STATE.SLIGHTLY_UNBALANCED_LEFT) {
            return rotateRight(node);
        }
        if (getBalanceFactor(leftNode) === BALANCE_STATE.SLIGHTLY_UNBALANCED_RIGHT) {
            node.left = rotateLeft(leftNode);
            return rotateRight(node);
        }
    }
    if (balanceFactor === BALANCE_STATE.UNBALANCED_RIGHT) {
        if (getBalanceFactor(rightNode) === BALANCE_STATE.BALANCED || getBalanceFactor(rightNode) === BALANCE_STATE.SLIGHTLY_UNBALANCED_RIGHT) {
            return rotateLeft(node);
        }
        if (getBalanceFactor(rightNode) === BALANCE_STATE.SLIGHTLY_UNBALANCED_LEFT) {
            node.right = rotateRight(rightNode);
            return rotateLeft(node);
        }
    }
    return node;
}
export function contains(node, key) {
    return !!find(node, key);
}
export function getSize(node) {
    if (!node) {
        return 0;
    }
    return 1 + getSize(node.left) + getSize(node.right);
}
export function isBalanced(node) {
    if (!node) {
        return true;
    }
    const heightDiff = Math.abs(getHeight(node.left) - getHeight(node.right));
    return heightDiff <= 1 && isBalanced(node.left) && isBalanced(node.right);
}
export function rangeSearch(node, min, max) {
    if (!node) {
        return [];
    }
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    const result = [];
    function traverse(node) {
        if (!node) {
            return;
        }
        if (node.key > min) {
            traverse(node.left);
        }
        if (node.key >= min && node.key <= max) {
            result.push(...node.value);
        }
        if (node.key < max) {
            traverse(node.right);
        }
    }
    traverse(node);
    return result;
}
export function greaterThan(node, key, inclusive = false) {
    if (!node) {
        return [];
    }
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    const result = [];
    function traverse(node) {
        if (!node) {
            return;
        }
        if (inclusive && node.key >= key) {
            result.push(...node.value);
        }
        if (!inclusive && node.key > key) {
            result.push(...node.value);
        }
        traverse(node.left);
        traverse(node.right);
    }
    traverse(node);
    return result;
}
export function lessThan(node, key, inclusive = false) {
    if (!node) {
        return [];
    }
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    const result = [];
    function traverse(node) {
        if (!node) {
            return;
        }
        if (inclusive && node.key <= key) {
            result.push(...node.value);
        }
        if (!inclusive && node.key < key) {
            result.push(...node.value);
        }
        traverse(node.left);
        traverse(node.right);
    }
    traverse(node);
    return result;
}

//# sourceMappingURL=index.js.map