{"version":3,"sources":["../../../src/trees/radix/index.ts"],"sourcesContent":["import { boundedLevenshtein } from \"../../levenshtein.js\";\nimport { getOwnProperty } from \"../../utils.js\";\nimport { addDocument, create as createNode, RadixNode, removeDocument, updateParent } from \"./node.js\";\n\nexport type FindParams = {\n  term: string;\n  exact?: boolean;\n  tolerance?: number;\n};\n\nexport type FindResult = Record<string, string[]>;\n\nexport function insert(root: RadixNode, word: string, docId: string) {\n  for (let i = 0; i < word.length; i++) {\n    const currentCharacter = word[i];\n    const wordAtIndex = word.substring(i);\n    const rootChildCurrentChar = root.children[currentCharacter];\n\n    if (currentCharacter in root.children) {\n      const edgeLabel = rootChildCurrentChar.subWord;\n      const edgeLabelLength = edgeLabel.length;\n\n      const commonPrefix = getCommonPrefix(edgeLabel, wordAtIndex);\n      const commonPrefixLength = commonPrefix.length;\n      const edgeLabelAtCommonPrefix = edgeLabel[commonPrefixLength];\n\n      // the wordAtIndex matches exactly with an existing child node\n      if (edgeLabel === wordAtIndex) {\n        addDocument(rootChildCurrentChar, docId);\n        rootChildCurrentChar.end = true;\n        return;\n      }\n\n      // the wordAtIndex is completely contained in the child node subword\n      if (commonPrefixLength < edgeLabelLength && commonPrefixLength === wordAtIndex.length) {\n        const newNode = createNode(true, wordAtIndex, currentCharacter);\n        newNode.children[edgeLabelAtCommonPrefix] = rootChildCurrentChar;\n\n        const newNodeChild = newNode.children[edgeLabelAtCommonPrefix];\n        newNodeChild.subWord = edgeLabel.substring(commonPrefixLength);\n        newNodeChild.key = edgeLabelAtCommonPrefix;\n\n        root.children[currentCharacter] = newNode;\n\n        updateParent(newNode, root);\n        updateParent(newNodeChild, newNode);\n        return;\n      }\n\n      // the wordAtIndex is partially contained in the child node subword\n      if (commonPrefixLength < edgeLabelLength && commonPrefixLength < wordAtIndex.length) {\n        const inbetweenNode = createNode(false, commonPrefix, currentCharacter);\n        inbetweenNode.children[edgeLabelAtCommonPrefix] = rootChildCurrentChar;\n        root.children[currentCharacter] = inbetweenNode;\n\n        const inbetweenNodeChild = inbetweenNode.children[edgeLabelAtCommonPrefix];\n        inbetweenNodeChild.subWord = edgeLabel.substring(commonPrefixLength);\n        inbetweenNodeChild.key = edgeLabelAtCommonPrefix;\n\n        const wordAtCommonPrefix = wordAtIndex[commonPrefixLength];\n        const newNode = createNode(true, word.substring(i + commonPrefixLength), wordAtCommonPrefix);\n        addDocument(newNode, docId);\n\n        inbetweenNode.children[wordAtCommonPrefix] = newNode;\n\n        updateParent(inbetweenNode, root);\n        updateParent(newNode, inbetweenNode);\n        updateParent(inbetweenNodeChild, inbetweenNode);\n        return;\n      }\n\n      // skip to the next divergent character\n      i += edgeLabelLength - 1;\n      // navigate in the child node\n      root = rootChildCurrentChar;\n    } else {\n      // if the node for the current character doesn't exist create new node\n      const newNode = createNode(true, wordAtIndex, currentCharacter);\n      addDocument(newNode, docId);\n\n      root.children[currentCharacter] = newNode;\n      updateParent(newNode, root);\n      return;\n    }\n  }\n}\n\nexport function find(root: RadixNode, { term, exact, tolerance }: FindParams) {\n  // find the closest node to the term\n  for (let i = 0; i < term.length; i++) {\n    const character = term[i];\n    if (character in root.children) {\n      const rootChildCurrentChar = root.children[character];\n      const edgeLabel = rootChildCurrentChar.subWord;\n      const termSubstring = term.substring(i);\n\n      // find the common prefix between two words ex: prime and primate = prim\n      const commonPrefix = getCommonPrefix(edgeLabel, termSubstring);\n      const commonPrefixLength = commonPrefix.length;\n      // if the common prefix lenght is equal to edgeLabel lenght (the node subword) it means they are a match\n      // if the common prefix is equal to the term means it is contained in the node\n      if (commonPrefixLength !== edgeLabel.length && commonPrefixLength !== termSubstring.length) {\n        // if tolerance is set we take the current node as the closest\n        if (tolerance) break;\n        return {};\n      }\n\n      // skip the subword lenght and check the next divergent character\n      i += rootChildCurrentChar.subWord.length - 1;\n      // navigate into the child node\n      root = rootChildCurrentChar;\n    } else {\n      return {};\n    }\n  }\n\n  const output: FindResult = {};\n  // found the closest node we recursively search through children\n  findAllWords(root, output, term, exact, tolerance);\n\n  return output;\n}\n\nfunction findAllWords(node: RadixNode, output: FindResult, term: string, exact?: boolean, tolerance?: number) {\n  if (node.end) {\n    const { word, docs: docIDs } = node;\n\n    if (exact && word !== term) {\n      return {};\n    }\n\n    // always check in own property to prevent access to inherited properties\n    // fix https://github.com/LyraSearch/lyra/issues/137\n    if (!getOwnProperty(output, word)) {\n      if (tolerance) {\n        // computing the absolute difference of letters between the term and the word\n        const difference = Math.abs(term.length - word.length);\n\n        // if the tolerance is set, check whether the edit distance is within tolerance.\n        // In that case, we don't need to add the word to the output\n        if (difference <= tolerance && boundedLevenshtein(term, word, tolerance).isBounded) {\n          output[word] = [];\n        }\n      } else {\n        // prevent default tolerance not set\n        output[word] = [];\n      }\n    }\n\n    // check if _output[word] exists and then add the doc to it\n    // always check in own property to prevent access to inherited properties\n    // fix https://github.com/LyraSearch/lyra/issues/137\n    if (getOwnProperty(output, word) && docIDs.length) {\n      const docs = new Set(output[word]);\n\n      const docIDsLength = docIDs.length;\n      for (let i = 0; i < docIDsLength; i++) {\n        docs.add(docIDs[i]);\n      }\n      output[word] = Array.from(docs);\n    }\n  }\n\n  // recursively search the children\n  for (const character of Object.keys(node.children)) {\n    findAllWords(node.children[character], output, term, exact, tolerance);\n  }\n  return output;\n}\n\nfunction getCommonPrefix(a: string, b: string) {\n  let commonPrefix = \"\";\n  const len = Math.min(a.length, b.length);\n  for (let i = 0; i < len; i++) {\n    if (a[i] !== b[i]) {\n      return commonPrefix;\n    }\n    commonPrefix += a[i];\n  }\n  return commonPrefix;\n}\n\nexport function contains(root: RadixNode, term: string): boolean {\n  for (let i = 0; i < term.length; i++) {\n    const character = term[i];\n\n    if (character in root.children) {\n      const rootChildrenChar = root.children[character];\n      const edgeLabel = rootChildrenChar.subWord;\n      const termSubstring = term.substring(i);\n      const commonPrefix = getCommonPrefix(edgeLabel, termSubstring);\n      const commonPrefixLength = commonPrefix.length;\n\n      if (commonPrefixLength !== edgeLabel.length && commonPrefixLength !== termSubstring.length) {\n        return false;\n      }\n      i += rootChildrenChar.subWord.length - 1;\n      root = rootChildrenChar;\n    } else {\n      return false;\n    }\n  }\n  return true;\n}\n\n// unused\nexport function removeWord(root: RadixNode, term: string): boolean {\n  if (!term) {\n    return false;\n  }\n\n  for (let i = 0; i < term.length; i++) {\n    const character = term[i];\n    const parent = root;\n    if (character in root.children) {\n      i += root.children[character].subWord.length - 1;\n      root = root.children[character];\n\n      if (Object.keys(root.children).length === 0) {\n        delete parent.children[root.key];\n        return true;\n      }\n    } else {\n      return false;\n    }\n  }\n\n  return false;\n}\n\nexport function removeDocumentByWord(root: RadixNode, term: string, docID: string, exact = true): boolean {\n  if (!term) {\n    return true;\n  }\n\n  for (let i = 0; i < term.length; i++) {\n    const character = term[i];\n    if (character in root.children) {\n      const rootChildCurrentChar = root.children[character];\n      i += rootChildCurrentChar.subWord.length - 1;\n      root = rootChildCurrentChar;\n\n      if (exact && root.word !== term) {\n        continue;\n      }\n\n      removeDocument(root, docID);\n    } else {\n      return false;\n    }\n  }\n  return true;\n}\n"],"names":["boundedLevenshtein","getOwnProperty","addDocument","create","createNode","removeDocument","updateParent","insert","root","word","docId","i","length","currentCharacter","wordAtIndex","substring","rootChildCurrentChar","children","edgeLabel","subWord","edgeLabelLength","commonPrefix","getCommonPrefix","commonPrefixLength","edgeLabelAtCommonPrefix","end","newNode","newNodeChild","key","inbetweenNode","inbetweenNodeChild","wordAtCommonPrefix","find","term","exact","tolerance","character","termSubstring","output","findAllWords","node","docs","docIDs","difference","Math","abs","isBounded","Set","docIDsLength","add","Array","from","Object","keys","a","b","len","min","contains","rootChildrenChar","removeWord","parent","removeDocumentByWord","docID"],"mappings":"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"}