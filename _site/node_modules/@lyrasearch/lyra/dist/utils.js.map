{"version":3,"sources":["../src/utils.ts"],"sourcesContent":["import type { TokenScore } from \"./types/index.js\";\n\nconst baseId = Date.now().toString().slice(5);\nlet lastId = 0;\n\nconst k = 1024;\nconst nano = BigInt(1e3);\nconst milli = BigInt(1e6);\nconst second = BigInt(1e9);\n\nexport const isServer = typeof window === \"undefined\";\n\nexport function formatBytes(bytes: number, decimals = 2): string {\n  if (bytes === 0) {\n    return \"0 Bytes\";\n  }\n  const dm = decimals < 0 ? 0 : decimals;\n  const sizes = [\"Bytes\", \"KB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\", \"ZB\", \"YB\"];\n  const i = Math.floor(Math.log(bytes) / Math.log(k));\n  return `${parseFloat((bytes / Math.pow(k, i)).toFixed(dm))} ${sizes[i]}`;\n}\n\nexport function formatNanoseconds(value: number | bigint): string {\n  if (typeof value === \"number\") {\n    value = BigInt(value);\n  }\n\n  if (value < nano) {\n    return `${value}ns`;\n  } else if (value < milli) {\n    return `${value / nano}Î¼s`;\n  } else if (value < second) {\n    return `${value / milli}ms`;\n  }\n\n  return `${value / second}s`;\n}\n\nexport function getNanosecondsTime(): bigint {\n  if (typeof process !== \"undefined\" && process.hrtime !== undefined) {\n    return process.hrtime.bigint();\n  }\n\n  if (typeof performance !== \"undefined\") {\n    return BigInt(Math.floor(performance.now() * 1e6));\n  }\n\n  // @todo: fallback to V8 native method to get microtime\n  return BigInt(0);\n}\n\nexport function uniqueId(): string {\n  return `${baseId}-${lastId++}`;\n}\n\nexport function getOwnProperty<T = unknown>(object: Record<string, T>, property: string): T | undefined {\n  // Checks if `hasOwn` method is defined avoiding errors with older Node.js versions\n  if (Object.hasOwn === undefined) {\n    return Object.prototype.hasOwnProperty.call(object, property) ? object[property] : undefined;\n  }\n\n  return Object.hasOwn(object, property) ? object[property] : undefined;\n}\n\nexport function getTokenFrequency(token: string, tokens: string[]): number {\n  let count = 0;\n\n  for (const t of tokens) {\n    if (t === token) {\n      count++;\n    }\n  }\n\n  return count;\n}\n\nexport function insertSortedValue(\n  arr: TokenScore[],\n  el: TokenScore,\n  compareFn = sortTokenScorePredicate,\n): TokenScore[] {\n  let low = 0;\n  let high = arr.length;\n  let mid;\n\n  while (low < high) {\n    mid = (low + high) >>> 1;\n    if (compareFn(el, arr[mid]) < 0) {\n      high = mid;\n    } else {\n      low = mid + 1;\n    }\n  }\n\n  arr.splice(low, 0, el);\n\n  return arr;\n}\n\nexport function sortTokenScorePredicate(a: TokenScore, b: TokenScore): number {\n  return b[1] - a[1];\n}\n\n// Intersection function taken from https://github.com/lovasoa/fast_array_intersect.\n// MIT Licensed at the time of writing.\nexport function intersect<T>(arrays: ReadonlyArray<T>[]): T[] {\n  if (arrays.length === 0) return [];\n\n  for (let i=1; i<arrays.length; i++) {\n    if(arrays[i].length < arrays[0].length) {\n      const tmp = arrays[0];\n      arrays[0] = arrays[i];\n      arrays[i] = tmp;\n    }\n  }\n\n  const set = new Map();\n  for(const elem of arrays[0]) {\n    set.set(elem, 1);\n  }\n  for (let i=1; i<arrays.length; i++) {\n    let found = 0;\n    for(const elem of arrays[i]) {\n      const count = set.get(elem)\n      if (count === i) {\n        set.set(elem,  count + 1);\n        found++;\n      }\n    }\n    if (found === 0) return []; \n  }\n\n  return arrays[0].filter(e => {\n    const count = set.get(e);\n    if (count !== undefined) set.set(e, 0);\n    return count === arrays.length\n  });\n}\n\n/**\n * Retrieve a deeply nested value from an object using a dot-separated string path.\n *\n * @template T - The expected type of the nested value.\n * @param {Record<string, any>} obj - The object to retrieve the value from.\n * @param {string} path - The dot-separated string path to the nested value.\n * @returns {(T | undefined)} - The nested value, or undefined if the path is invalid.\n */\n\nexport function getNested<T = unknown>(\n  obj: Record<string, any>,\n  path: string\n): T | undefined {\n  return path.split(\".\").reduce((o, p) => o && typeof o === \"object\" ? o[p] : undefined, obj) as T | undefined;\n}\n\n/**\n * Flattens an object with deeply nested properties, such that (for example), this:\n * `{ foo: { bar: { baz: 10 } } }` becomes: `{ 'foo.bar.baz': 10 }`\n *\n * @param {object} obj - The object to flatten.\n * @param {string} [prefix=''] - The prefix to use for each key in the flattened object.\n * @returns {object} - The flattened object.\n */\n\nexport function flattenObject(obj: object, prefix = ''): object {\n  const result: { [key: string]: any } = {};\n  for (const key in obj) {\n    const objKey = (obj as any)[key];\n    if (typeof objKey === 'object' && objKey !== null) {\n      Object.assign(result, flattenObject(objKey, prefix + key + '.'));\n    } else {\n      result[prefix + key] = objKey;\n    }\n  }\n  return result;\n}\n"],"names":["baseId","Date","now","toString","slice","lastId","k","nano","BigInt","milli","second","isServer","window","formatBytes","bytes","decimals","dm","sizes","i","Math","floor","log","parseFloat","pow","toFixed","formatNanoseconds","value","getNanosecondsTime","process","hrtime","undefined","bigint","performance","uniqueId","getOwnProperty","object","property","Object","hasOwn","prototype","hasOwnProperty","call","getTokenFrequency","token","tokens","count","t","insertSortedValue","arr","el","compareFn","sortTokenScorePredicate","low","high","length","mid","splice","a","b","intersect","arrays","tmp","set","Map","elem","found","get","filter","e","getNested","obj","path","split","reduce","o","p","flattenObject","prefix","result","key","objKey","assign"],"mappings":"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"}