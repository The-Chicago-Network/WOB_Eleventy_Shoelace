import type { TokenScore } from "./types/index.js";
export declare const isServer: boolean;
export declare function formatBytes(bytes: number, decimals?: number): string;
export declare function formatNanoseconds(value: number | bigint): string;
export declare function getNanosecondsTime(): bigint;
export declare function uniqueId(): string;
export declare function getOwnProperty<T = unknown>(object: Record<string, T>, property: string): T | undefined;
export declare function getTokenFrequency(token: string, tokens: string[]): number;
export declare function insertSortedValue(arr: TokenScore[], el: TokenScore, compareFn?: typeof sortTokenScorePredicate): TokenScore[];
export declare function sortTokenScorePredicate(a: TokenScore, b: TokenScore): number;
export declare function intersect<T>(arrays: ReadonlyArray<T>[]): T[];
/**
 * Retrieve a deeply nested value from an object using a dot-separated string path.
 *
 * @template T - The expected type of the nested value.
 * @param {Record<string, any>} obj - The object to retrieve the value from.
 * @param {string} path - The dot-separated string path to the nested value.
 * @returns {(T | undefined)} - The nested value, or undefined if the path is invalid.
 */
export declare function getNested<T = unknown>(obj: Record<string, any>, path: string): T | undefined;
/**
 * Flattens an object with deeply nested properties, such that (for example), this:
 * `{ foo: { bar: { baz: 10 } } }` becomes: `{ 'foo.bar.baz': 10 }`
 *
 * @param {object} obj - The object to flatten.
 * @param {string} [prefix=''] - The prefix to use for each key in the flattened object.
 * @returns {object} - The flattened object.
 */
export declare function flattenObject(obj: object, prefix?: string): object;
