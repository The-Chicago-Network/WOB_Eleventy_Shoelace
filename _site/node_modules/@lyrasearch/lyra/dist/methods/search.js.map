{"version":3,"sources":["../../src/methods/search.ts"],"sourcesContent":["import type { RadixNode } from \"../trees/radix/node.js\";\nimport type { Lyra, PropertiesSchema, ResolveSchema, SearchProperties, TokenMap, TokenScore, BM25Params, BM25OptionalParams, PropertiesBoost, FacetsSearch } from \"../types/index.js\";\nimport type { WhereFilter } from \"../types/filters.js\";\nimport { defaultTokenizerConfig, Language } from \"../tokenizer/index.js\";\nimport { find as radixFind } from \"../trees/radix/index.js\";\nimport { formatNanoseconds, getNanosecondsTime, sortTokenScorePredicate } from \"../utils.js\";\nimport { getIndices } from \"./common.js\";\nimport { prioritizeTokenScores, BM25 } from \"../algorithms.js\";\nimport { FacetReturningValue, getFacets } from \"../facets.js\";\nimport { getWhereFiltersIDs, intersectFilteredIDs } from \"../filters.js\";\n\ntype IndexMap = Record<string, TokenMap>;\n\nexport type RetrievedDoc<S extends PropertiesSchema> = {\n  /**\n   * The id of the document.\n   */\n  id: string;\n  /**\n   * The score of the document in the search.\n   */\n  score: number;\n  /**\n   * The document\n   */\n  document: ResolveSchema<S>;\n};\n\nexport type SearchParams<S extends PropertiesSchema> = {\n  /**\n   * The word to search.\n   */\n  term: string;\n  /**\n   * The properties of the document to search in.\n   */\n  properties?: \"*\" | SearchProperties<S>[];\n  /**\n   * The number of matched documents to return.\n   */\n  limit?: number;\n  /**\n   * The number of matched documents to skip.\n   */\n  offset?: number;\n  /**\n   * Whether to match the term exactly.\n   */\n  exact?: boolean;\n  /**\n   * The maximum [levenshtein distance](https://en.wikipedia.org/wiki/Levenshtein_distance)\n   * between the term and the searchable property.\n   */\n  tolerance?: number;\n  /**\n   * The BM25 parameters to use.\n   * \n   * k: Term frequency saturation parameter.\n   * The higher the value, the more important the term frequency becomes.\n   * The default value is 1.2. It should be set to a value between 1.2 and 2.0.\n   * \n   * b: Document length saturation impact. The higher the value, the more\n   * important the document length becomes. The default value is 0.75.\n   * \n   * d: Frequency normalization lower bound. Default value is 0.5.\n   * \n   * @see https://en.wikipedia.org/wiki/Okapi_BM25\n   */\n  relevance?: BM25OptionalParams;\n  /**\n   * The boost to apply to the properties.\n   * \n   * The boost is a number that is multiplied to the score of the property.\n   * It can be used to give more importance to some properties. \n   * \n   * @example\n   * // Give more importance to the 'title' property.\n   * const result = await search(db, {\n   *  term: 'Michael',\n   *  properties: ['title', 'author'],\n   *  boost: {\n   *   title: 2\n   *  }\n   * });\n   * \n   * // In that case, the score of the 'title' property will be multiplied by 2.\n   */\n  boost?: PropertiesBoost<S>;\n  /**\n   * Facets configuration\n   * \n   * A facet is a feature that allows users to narrow down their search results by specific\n   * attributes or characteristics, such as category, price, or location.\n   * This can help users find more relevant and specific results for their search query.\n   * \n   * @example\n   * \n   * const results = await search(db, {\n   *  term: 'Personal Computer',\n   *  properties: ['title', 'description', 'category.primary', 'category.secondary'],\n   *  facets: {\n   *    'category.primary': {\n   *      size: 10,\n   *      sort: 'ASC',\n   *    }\n   *  }\n   * });\n   */\n  facets?: FacetsSearch<S>;\n\n  /**\n   * Filter the search results.\n   * \n   * @example\n   * // Search for documents that contain 'Headphones' in the 'description' and 'title' fields and\n   * // have a price less than 100.\n   * \n   * const result = await search(db, {\n   *  term: 'Headphones',\n   *  properties: ['description', 'title'],\n   *  where: {\n   *    price: {\n   *      lt: 100\n   *    }\n   *  }\n   * });\n   */\n  where?: WhereFilter<S>;\n};\n\nexport type SearchResult<S extends PropertiesSchema> = {\n  /**\n   * The number of all the matched documents.\n   */\n  count: number;\n  /**\n   * An array of matched documents taking `limit` and `offset` into account.\n   */\n  hits: RetrievedDoc<S>[];\n  /**\n   * The time taken to search.\n   */\n  elapsed: bigint | string;\n  /**\n   * The facets results.\n   */\n  facets?: FacetReturningValue;\n};\n\n/**\n * Searches for documents in a database.\n * @param lyra The database to search.\n * @param params The search query.\n * @param language Optional parameter to override the default language analyzer.\n * @example\n * // Search for documents that contain 'Michael' in the 'author' field.\n * const result = await search(db, {\n *   term: 'Michael',\n *   properties: ['author']\n * });\n */\nexport async function search<S extends PropertiesSchema>(\n  lyra: Lyra<S>,\n  params: SearchParams<S>,\n  language?: Language,\n): Promise<SearchResult<S>> {\n  if (!language) {\n    language = lyra.defaultLanguage;\n  }\n\n  if (!lyra.components?.tokenizer) {\n    lyra.components = {\n      ...(lyra.components ?? {}),\n      tokenizer: defaultTokenizerConfig(language),\n    };\n  }\n\n  params.relevance = getBM25Parameters(params.relevance);\n\n  const shouldCalculateFacets = params.facets && Object.keys(params.facets).length > 0;\n  const { limit = 10, offset = 0, exact = false, term, properties } = params;\n  const tokens = lyra.components.tokenizer!.tokenizerFn!(term, language, false, lyra.components.tokenizer!);\n  const indices = getIndices(lyra, properties);\n  const results: RetrievedDoc<S>[] = Array.from({\n    length: limit,\n  });\n  const N = lyra.docsCount;\n\n  const timeStart = getNanosecondsTime();\n\n  // If filters are enabled, we need to get the IDs of the documents that match the filters.\n  const hasFilters = Object.keys(params.where ?? {}).length > 0;\n  let whereFiltersIDs: string[] = [];\n\n  if (hasFilters) {\n    whereFiltersIDs = getWhereFiltersIDs(params.where!, lyra);\n  }\n\n  // uniqueDocsIDs contains unique document IDs for all the tokens in all the indices.\n  const uniqueDocsIDs: Record<string, number> = {};\n\n  // indexMap is an object containing all the indexes considered for the current search,\n  // and an array of doc IDs for each token in all the indices.\n  //\n  // Given the search term \"quick brown fox\" on the \"description\" index,\n  // indexMap will look like this:\n  //\n  // {\n  //   description: {\n  //     quick: [doc1, doc2, doc3],\n  //     brown: [doc2, doc4],\n  //     fox:   [doc2]\n  //   }\n  // }\n  const indexMap: IndexMap = {};\n  // After we create the indexMap, we need to calculate the intersection\n  // between all the postings lists for each token.\n  // Given the example above, docsIntersection will look like this:\n  //\n  // {\n  //   description: [doc2]\n  // }\n  //\n  // as doc2 is the only document present in all the postings lists for the \"description\" index.\n  const docsIntersection: TokenMap = {};\n\n  for (const index of indices) {\n    const tokensMap: TokenMap = {};\n    for (const token of tokens) {\n      tokensMap[token] = [];\n    }\n    indexMap[index] = tokensMap;\n    docsIntersection[index] = [];\n  }\n\n  // Now it's time to loop over all the indices and get the documents IDs for every single term\n  const indexesLength = indices.length;\n  for (let i = 0; i < indexesLength; i++) {\n    const index = indices[i];\n    const avgFieldLength = lyra.avgFieldLength[index];\n    const fieldLengths = lyra.fieldLengths[index];\n\n    if (!(index in lyra.tokenOccurrencies)) continue;\n\n    const lyraOccurrencies = lyra.tokenOccurrencies[index];\n    const lyraFrequencies = lyra.frequencies[index];\n\n    const tokensLength = tokens.length;\n    for (let j = 0; j < tokensLength; j++) {\n      const term = tokens[j];\n\n      // Here we get a TypeScript error: Type instantiation is excessively deep and possibly infinite.\n      // Type definition is correct, but TypeScript is not able to infer the type recursively.\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      const documentIDs = getDocumentIDsFromSearch(lyra, { ...params, index, term, exact });\n\n      // lyraOccurrencies[term] can be undefined, 0, string, or { [k: string]: number }\n      const termOccurrencies = typeof lyraOccurrencies[term] === \"number\" ? lyraOccurrencies[term] ?? 0 : 0;\n\n      const scoreList: TokenScore[] = [];\n\n      // Calculate TF-IDF value for each term, in each document, for each index.\n      // Then insert sorted results into orderedTFIDFList.\n      const documentIDsLength = documentIDs.length;\n      for (let k = 0; k < documentIDsLength; k++) {\n        const id = documentIDs[k];\n        const tf = lyraFrequencies?.[id]?.[term] ?? 0;\n\n        const bm25 = BM25(\n          tf,\n          termOccurrencies,\n          N,\n          fieldLengths[id],\n          avgFieldLength,\n          params.relevance as BM25Params,\n        );\n\n        scoreList.push([id, bm25]);\n      }\n\n      indexMap[index][term].push(...scoreList);\n    }\n\n    const docIds = indexMap[index];\n    const vals = Object.values(docIds);\n    docsIntersection[index] = prioritizeTokenScores(vals, params?.boost?.[index] ?? 1);\n    const uniqueDocs = docsIntersection[index];\n\n    const uniqueDocsLength = uniqueDocs.length;\n    for (let i = 0; i < uniqueDocsLength; i++) {\n      const [id, tfIdfScore] = uniqueDocs[i];\n\n      const prevScore = uniqueDocsIDs[id];\n      if (prevScore) {\n        uniqueDocsIDs[id] = prevScore + tfIdfScore + 0.5;\n      } else {\n        uniqueDocsIDs[id] = tfIdfScore;\n      }\n    }\n  }\n\n  // Get unique doc IDs from uniqueDocsIDs map, sorted by value.\n  let uniqueDocsArray = Object.entries(uniqueDocsIDs).sort(sortTokenScorePredicate);\n  \n  // If filters are enabled, we need to remove the IDs of the documents that don't match the filters.\n  if (hasFilters) {\n    uniqueDocsArray = intersectFilteredIDs(whereFiltersIDs, uniqueDocsArray);\n  }\n\n  const resultIDs: Set<string> = new Set();\n  // Populate facets if needed\n  const facets = shouldCalculateFacets ? getFacets(lyra.schema, lyra.docs, uniqueDocsArray, params.facets!) : {};\n\n  // We already have the list of ALL the document IDs containing the search terms.\n  // We loop over them starting from a positional value \"offset\" and ending at \"offset + limit\"\n  // to provide pagination capabilities to the search.\n  for (let i = offset; i < limit + offset; i++) {\n    const idAndScore = uniqueDocsArray[i];\n\n    // If there are no more results, just break the loop\n    if (typeof idAndScore === \"undefined\") {\n      break;\n    }\n\n    const [id, score] = idAndScore;\n\n    if (!resultIDs.has(id)) {\n      // We retrieve the full document only AFTER making sure that we really want it.\n      // We never retrieve the full document preventively.\n      const fullDoc = lyra.docs[id]!;\n      results[i] = { id, score, document: fullDoc };\n      resultIDs.add(id);\n    }\n  }\n\n  let elapsed: bigint | string = getNanosecondsTime() - timeStart;\n\n  if (lyra.components.elapsed?.format === \"human\") {\n    elapsed = formatNanoseconds(elapsed);\n  }\n\n  const searchResult: SearchResult<S> = {\n    elapsed,\n    hits: results.filter(Boolean),\n    count: uniqueDocsArray.length,\n  };\n\n  if (shouldCalculateFacets) {\n    searchResult.facets = facets;\n  }\n\n  return searchResult;\n}\n\nfunction getDocumentIDsFromSearch<S extends PropertiesSchema>(\n  lyra: Lyra<S>,\n  params: SearchParams<S> & { index: string },\n): string[] {\n  const idx = lyra.index[params.index];\n  const searchResult = radixFind(idx as RadixNode, {\n    term: params.term,\n    exact: params.exact,\n    tolerance: params.tolerance,\n  });\n\n  const ids = new Set<string>();\n\n  for (const key in searchResult) {\n    for (const id of searchResult[key]) {\n      ids.add(id);\n    }\n  }\n\n  return Array.from(ids);\n}\n\nconst defaultBM25Params: BM25Params = {\n  k: 1.2,\n  b: 0.75,\n  d: 0.5\n}\n\nfunction getBM25Parameters(params: BM25OptionalParams = defaultBM25Params): BM25Params {\n  return Object.assign({}, defaultBM25Params, params);\n}\n"],"names":["defaultTokenizerConfig","find","radixFind","formatNanoseconds","getNanosecondsTime","sortTokenScorePredicate","getIndices","prioritizeTokenScores","BM25","getFacets","getWhereFiltersIDs","intersectFilteredIDs","search","lyra","params","language","defaultLanguage","components","tokenizer","relevance","getBM25Parameters","shouldCalculateFacets","facets","Object","keys","length","limit","offset","exact","term","properties","tokens","tokenizerFn","indices","results","Array","from","N","docsCount","timeStart","hasFilters","where","whereFiltersIDs","uniqueDocsIDs","indexMap","docsIntersection","index","tokensMap","token","indexesLength","i","avgFieldLength","fieldLengths","tokenOccurrencies","lyraOccurrencies","lyraFrequencies","frequencies","tokensLength","j","documentIDs","getDocumentIDsFromSearch","termOccurrencies","scoreList","documentIDsLength","k","id","tf","bm25","push","docIds","vals","values","boost","uniqueDocs","uniqueDocsLength","tfIdfScore","prevScore","uniqueDocsArray","entries","sort","resultIDs","Set","schema","docs","idAndScore","score","has","fullDoc","document","add","elapsed","format","searchResult","hits","filter","Boolean","count","idx","tolerance","ids","key","defaultBM25Params","b","d","assign"],"mappings":"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"}