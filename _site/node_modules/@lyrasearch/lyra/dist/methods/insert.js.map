{"version":3,"sources":["../../src/methods/insert.ts"],"sourcesContent":["import type { Lyra, PropertiesSchema, ResolveSchema } from \"../types/index.js\";\nimport type { Language, TokenizerConfigExec } from \"../tokenizer/index.js\";\nimport type { AVLNode } from \"../../src/trees/avl/node.js\";\nimport type { RadixNode } from \"../trees/radix/node.js\";\nimport { trackInsertion } from \"../insertion-checker.js\";\nimport { insert as radixInsert } from \"../trees/radix/index.js\";\nimport { insert as AVLInsert } from \"../trees/avl/index.js\";\nimport { uniqueId } from \"../utils.js\";\nimport { assertDocSchema } from \"./common.js\";\nimport { hookRunner } from \"./hooks.js\";\nimport * as ERRORS from \"../errors.js\";\n\nexport type InsertConfig<S extends PropertiesSchema> = {\n  language?: Language;\n  id?: (doc: ResolveSchema<S>) => string | Promise<string>;\n};\n\nexport type InsertBatchConfig<S extends PropertiesSchema> = InsertConfig<S> & {\n  batchSize?: number;\n};\n\n/**\n * Inserts a document into a database.\n * @param lyra The database to insert document into.\n * @param doc The document to insert.\n * @param config Optional parameter for overriding default configuration.\n * @returns An object containing id of the inserted document.\n * @example\n * const { id } = await insert(db, {\n *   quote: 'You miss 100% of the shots you don\\'t take',\n *   author: 'Wayne Gretzky - Michael Scott'\n * });\n */\nexport async function insert<S extends PropertiesSchema>(\n  lyra: Lyra<S>,\n  doc: ResolveSchema<S>,\n  config?: InsertConfig<S>,\n): Promise<{ id: string }> {\n  config = { language: lyra.defaultLanguage, ...config };\n\n  const id = await getDocumentID(doc, config);\n\n  // If the ID already exists, we throw an error.\n  if (lyra.docs[id]) throw new Error(ERRORS.ID_ALREADY_EXISTS(id));\n\n  lyra.components?.tokenizer?.assertSupportedLanguage?.(config.language!);\n\n  assertDocSchema(doc, lyra.schema);\n\n  lyra.docs[id] = doc;\n  lyra.docsCount++;\n  recursiveradixInsertion(lyra, doc, id, config, undefined, lyra.components?.tokenizer as TokenizerConfigExec);\n  trackInsertion(lyra);\n\n  return { id };\n}\n\n/**\n * Inserts a document into a database.\n * @param lyra The database to insert document into.\n * @param doc The document to insert.\n * @param config Optional parameter for overriding default configuration.\n * @returns A Promise object containing id of the inserted document.\n * @example\n * const { id } = await insert(db, {\n *   quote: 'You miss 100% of the shots you don\\'t take',\n *   author: 'Wayne Gretzky - Michael Scott'\n * });\n */\nexport async function insertWithHooks<S extends PropertiesSchema>(\n  lyra: Lyra<S>,\n  doc: ResolveSchema<S>,\n  config?: InsertConfig<S>,\n): Promise<{ id: string }> {\n  config = { language: lyra.defaultLanguage, ...config };\n  const id = await getDocumentID(doc, config);\n\n  lyra.components?.tokenizer?.assertSupportedLanguage?.(config.language!);\n\n  assertDocSchema(doc, lyra.schema);\n\n  lyra.docs[id] = doc;\n  lyra.docsCount++;\n  recursiveradixInsertion(lyra, doc, id, config, undefined, lyra.components?.tokenizer as TokenizerConfigExec);\n  trackInsertion(lyra);\n  if (lyra.hooks.afterInsert) {\n    await hookRunner.call(lyra, lyra.hooks.afterInsert, id);\n  }\n\n  return { id };\n}\n\n/**\n * Inserts a large array of documents into a database without blocking the event loop.\n * @param lyra The database to insert document into.\n * @param docs Array of documents to insert.\n * @param config Optional parameter for overriding default configuration.\n * @returns Promise<void>.\n * @example\n * insertBatch(db, [\n *   {\n *     quote: 'You miss 100% of the shots you don\\'t take',\n *     author: 'Wayne Gretzky - Michael Scott'\n *   },\n *   {\n *     quote: 'What I cannot createm I do not understand',\n *     author: 'Richard Feynman'\n *   }\n * ]);\n */\nexport async function insertBatch<S extends PropertiesSchema>(\n  lyra: Lyra<S>,\n  docs: ResolveSchema<S>[],\n  config?: InsertBatchConfig<S>,\n): Promise<void> {\n  const batchSize = config?.batchSize ?? 1000;\n\n  return new Promise((resolve, reject) => {\n    let i = 0;\n    async function _insertBatch() {\n      const batch = docs.slice(i * batchSize, (i + 1) * batchSize);\n      i++;\n\n      if (!batch.length) {\n        return resolve();\n      }\n\n      for (const line of batch) {\n        try {\n          await insertWithHooks(lyra, line, config);\n        } catch (err) {\n          reject(err);\n        }\n      }\n\n      setTimeout(_insertBatch, 0);\n    }\n\n    setTimeout(_insertBatch, 0);\n  });\n}\n\nfunction recursiveradixInsertion<S extends PropertiesSchema>(\n  lyra: Lyra<S>,\n  doc: ResolveSchema<S>,\n  id: string,\n  config: InsertConfig<S>,\n  prefix = \"\",\n  tokenizerConfig: TokenizerConfigExec,\n  schema: PropertiesSchema = lyra.schema,\n) {\n  config = { language: lyra.defaultLanguage, ...config };\n  const { index, frequencies, tokenOccurrencies } = lyra;\n\n  for (const key of Object.keys(doc)) {\n    const isNested = typeof doc[key] === \"object\";\n    const isSchemaNested = typeof schema[key] == \"object\";\n    const propName = `${prefix}${key}`;\n    if (isNested && key in schema && isSchemaNested) {\n      recursiveradixInsertion(\n        lyra,\n        doc[key] as ResolveSchema<S>,\n        id,\n        config,\n        propName + \".\",\n        tokenizerConfig,\n        schema[key] as PropertiesSchema,\n      );\n    }\n\n    \n    if (typeof doc[key] === \"number\" && key in schema && !isSchemaNested) {\n      AVLInsert(lyra.index[propName] as AVLNode<number, string[]>, doc[key] as number, [id]);\n    }\n\n    if (typeof doc[key] === \"string\" && key in schema && !isSchemaNested) {\n      // Use propName here because if doc is a nested object\n      // We will get the wrong index\n      const requestedTrie = index[propName];\n      const tokens = tokenizerConfig.tokenizerFn(doc[key] as string, config.language!, false, tokenizerConfig);\n\n      if (!(propName in frequencies)) {\n        frequencies[propName] = {};\n      }\n\n      if (!(propName in tokenOccurrencies)) {\n        tokenOccurrencies[propName] = {};\n      }\n\n      if (!(id in frequencies[propName])) {\n        frequencies[propName][id] = {};\n      }\n\n      if (!(propName in lyra.fieldLengths)) {\n        lyra.fieldLengths[propName] = {};\n      }\n      \n      lyra.fieldLengths[propName][id] = tokens.length;\n      lyra.avgFieldLength[propName] = ((lyra.avgFieldLength[propName] ?? 0) * (lyra.docsCount - 1) + tokens.length) / lyra.docsCount;\n\n      for (const token of tokens) {\n        let tokenFrequency = 0;\n\n        for (const t of tokens) {\n          if (t === token) {\n            tokenFrequency++;\n          }\n        }\n\n        const tf = tokenFrequency / tokens.length;\n\n        frequencies[propName][id][token] = tf;\n\n        if (!(token in tokenOccurrencies[propName])) {\n          tokenOccurrencies[propName][token] = 0;\n        }\n\n        // increase a token counter that may not yet exist\n        tokenOccurrencies[propName][token] = (tokenOccurrencies[propName][token] ?? 0) + 1;\n\n        radixInsert(requestedTrie as RadixNode, token, id);\n      }\n    }\n  }\n}\n\nasync function getDocumentID<S extends PropertiesSchema>(\n  doc: ResolveSchema<S>,\n  config: InsertConfig<S>,\n): Promise<string> {\n  let id: string;\n\n  // If the user passes a custom ID function, we use it to generate the ID.\n  // This has the maximum priority.\n  if (config?.id) {\n    id = await config.id(doc);\n\n    // If the user passes an ID in the document, we use it.\n  } else if (doc.id && typeof doc.id === \"string\") {\n    id = doc.id;\n\n    // If the user passes an ID in the document, but it's not a string, we throw a type error.\n  } else if (doc.id && typeof doc.id !== \"string\") {\n    throw new TypeError(ERRORS.TYPE_ERROR_ID_MUST_BE_STRING(typeof doc.id));\n\n    // If the user doesn't pass an ID, we generate one.\n  } else {\n    id = uniqueId();\n  }\n\n  return id;\n}\n"],"names":["trackInsertion","insert","radixInsert","AVLInsert","uniqueId","assertDocSchema","hookRunner","ERRORS","lyra","doc","config","language","defaultLanguage","id","getDocumentID","docs","Error","ID_ALREADY_EXISTS","components","tokenizer","assertSupportedLanguage","schema","docsCount","recursiveradixInsertion","undefined","insertWithHooks","hooks","afterInsert","call","insertBatch","batchSize","Promise","resolve","reject","i","_insertBatch","batch","slice","length","line","err","setTimeout","prefix","tokenizerConfig","index","frequencies","tokenOccurrencies","key","Object","keys","isNested","isSchemaNested","propName","requestedTrie","tokens","tokenizerFn","fieldLengths","avgFieldLength","token","tokenFrequency","t","tf","TypeError","TYPE_ERROR_ID_MUST_BE_STRING"],"mappings":"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"}