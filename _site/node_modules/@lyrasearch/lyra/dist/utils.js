const baseId = Date.now().toString().slice(5);
let lastId = 0;
const k = 1024;
const nano = BigInt(1e3);
const milli = BigInt(1e6);
const second = BigInt(1e9);
export const isServer = typeof window === "undefined";
export function formatBytes(bytes, decimals = 2) {
    if (bytes === 0) {
        return "0 Bytes";
    }
    const dm = decimals < 0 ? 0 : decimals;
    const sizes = [
        "Bytes",
        "KB",
        "MB",
        "GB",
        "TB",
        "PB",
        "EB",
        "ZB",
        "YB"
    ];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return `${parseFloat((bytes / Math.pow(k, i)).toFixed(dm))} ${sizes[i]}`;
}
export function formatNanoseconds(value) {
    if (typeof value === "number") {
        value = BigInt(value);
    }
    if (value < nano) {
        return `${value}ns`;
    } else if (value < milli) {
        return `${value / nano}Î¼s`;
    } else if (value < second) {
        return `${value / milli}ms`;
    }
    return `${value / second}s`;
}
export function getNanosecondsTime() {
    if (typeof process !== "undefined" && process.hrtime !== undefined) {
        return process.hrtime.bigint();
    }
    if (typeof performance !== "undefined") {
        return BigInt(Math.floor(performance.now() * 1e6));
    }
    // @todo: fallback to V8 native method to get microtime
    return BigInt(0);
}
export function uniqueId() {
    return `${baseId}-${lastId++}`;
}
export function getOwnProperty(object, property) {
    // Checks if `hasOwn` method is defined avoiding errors with older Node.js versions
    if (Object.hasOwn === undefined) {
        return Object.prototype.hasOwnProperty.call(object, property) ? object[property] : undefined;
    }
    return Object.hasOwn(object, property) ? object[property] : undefined;
}
export function getTokenFrequency(token, tokens) {
    let count = 0;
    for (const t of tokens){
        if (t === token) {
            count++;
        }
    }
    return count;
}
export function insertSortedValue(arr, el, compareFn = sortTokenScorePredicate) {
    let low = 0;
    let high = arr.length;
    let mid;
    while(low < high){
        mid = low + high >>> 1;
        if (compareFn(el, arr[mid]) < 0) {
            high = mid;
        } else {
            low = mid + 1;
        }
    }
    arr.splice(low, 0, el);
    return arr;
}
export function sortTokenScorePredicate(a, b) {
    return b[1] - a[1];
}
// Intersection function taken from https://github.com/lovasoa/fast_array_intersect.
// MIT Licensed at the time of writing.
export function intersect(arrays) {
    if (arrays.length === 0) return [];
    for(let i = 1; i < arrays.length; i++){
        if (arrays[i].length < arrays[0].length) {
            const tmp = arrays[0];
            arrays[0] = arrays[i];
            arrays[i] = tmp;
        }
    }
    const set = new Map();
    for (const elem of arrays[0]){
        set.set(elem, 1);
    }
    for(let i = 1; i < arrays.length; i++){
        let found = 0;
        for (const elem of arrays[i]){
            const count = set.get(elem);
            if (count === i) {
                set.set(elem, count + 1);
                found++;
            }
        }
        if (found === 0) return [];
    }
    return arrays[0].filter((e)=>{
        const count = set.get(e);
        if (count !== undefined) set.set(e, 0);
        return count === arrays.length;
    });
}
/**
 * Retrieve a deeply nested value from an object using a dot-separated string path.
 *
 * @template T - The expected type of the nested value.
 * @param {Record<string, any>} obj - The object to retrieve the value from.
 * @param {string} path - The dot-separated string path to the nested value.
 * @returns {(T | undefined)} - The nested value, or undefined if the path is invalid.
 */ export function getNested(obj, path) {
    return path.split(".").reduce((o, p)=>o && typeof o === "object" ? o[p] : undefined, obj);
}
/**
 * Flattens an object with deeply nested properties, such that (for example), this:
 * `{ foo: { bar: { baz: 10 } } }` becomes: `{ 'foo.bar.baz': 10 }`
 *
 * @param {object} obj - The object to flatten.
 * @param {string} [prefix=''] - The prefix to use for each key in the flattened object.
 * @returns {object} - The flattened object.
 */ export function flattenObject(obj, prefix = '') {
    const result = {};
    for(const key in obj){
        const objKey = obj[key];
        if (typeof objKey === 'object' && objKey !== null) {
            Object.assign(result, flattenObject(objKey, prefix + key + '.'));
        } else {
            result[prefix + key] = objKey;
        }
    }
    return result;
}

//# sourceMappingURL=utils.js.map