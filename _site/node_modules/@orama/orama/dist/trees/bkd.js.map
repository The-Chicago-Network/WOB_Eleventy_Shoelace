{"version":3,"sources":["../../src/trees/bkd.ts"],"sourcesContent":["import type { Nullable, GenericSorting } from '../types.js'\nimport type { InternalDocumentID } from '../components/internal-document-id-store.js'\n\nexport interface Point {\n  lon: number\n  lat: number\n}\n\nexport interface Node {\n  point: Point\n  docIDs?: InternalDocumentID[]\n  left?: Node\n  right?: Node\n  parent?: Node\n}\n\nexport interface RootNode {\n  root: Nullable<Node>\n}\n\nexport interface GeoSearchResult {\n  point: Point\n  docIDs: InternalDocumentID[]\n}\n\nexport type SortGeoPoints = Nullable<GenericSorting>\n\ninterface SearchTask {\n  node: Nullable<Node>\n  depth: number\n}\n\nconst K = 2 // 2D points\nconst EARTH_RADIUS = 6371e3 // Earth radius in meters\n\nexport function create (): RootNode {\n  return { root: null }\n}\n\nexport function insert (tree: RootNode, point: Point, docIDs: InternalDocumentID[]): void {\n  const newNode: Node = { point, docIDs }\n\n  if (tree.root == null) {\n    tree.root = newNode\n    return\n  }\n\n  let node: Nullable<Node> = tree.root\n  let depth = 0\n\n  while (node !== null) {\n    // Check if the current node's point matches the new point\n    if (node.point.lon === point.lon && node.point.lat === point.lat) {\n      // Merge the new docIDs with the existing ones and remove duplicates\n      const newDocIDs = node.docIDs ?? []\n      node.docIDs = Array.from(new Set([...newDocIDs, ...docIDs || []]))\n      return\n    }\n\n    const axis = depth % K\n\n    // Compare by longitude\n    if (axis === 0) {\n      if (point.lon < node.point.lon) {\n        if (node.left == null) {\n          node.left = newNode\n          return\n        }\n        node = node.left\n      } else {\n        if (node.right == null) {\n          node.right = newNode\n          return\n        }\n        node = node.right\n      }\n    // Compare by latitude\n    } else {\n      if (point.lat < node.point.lat) {\n        if (node.left == null) {\n          node.left = newNode\n          return\n        }\n        node = node.left\n      } else {\n        if (node.right == null) {\n          node.right = newNode\n          return\n        }\n        node = node.right\n      }\n    }\n\n    depth++\n  }\n}\n\nexport function contains (tree: RootNode, point: Point): boolean {\n  let node: Nullable<Node> | undefined = tree.root\n  let depth = 0\n\n  while (node != null) {\n    if (node?.point.lon === point.lon && node.point.lat === point.lat) {\n      return true\n    }\n\n    const axis = depth % K\n\n    // Compare by longitude\n    if (axis === 0) {\n      if (point.lon < node.point.lon) {\n        node = node?.left\n      } else {\n        node = node?.right\n      }\n    // Compare by latitude\n    } else {\n      if (point.lat < node.point.lat) {\n        node = node?.left\n      } else {\n        node = node?.right\n      }\n    }\n\n    depth++\n  }\n\n  return false\n}\n\n// @todo: this is very inefficient. Fix this later.\nexport function removeDocByID (tree: RootNode, point: Point, docID: InternalDocumentID): void {\n  let node: Nullable<Node> | undefined = tree.root\n  let depth = 0\n  let parentNode: Nullable<Node> = null\n  let direction: 'left' | 'right' | null = null\n\n  while (node !== null) {\n    if (node?.point.lon === point.lon && node.point.lat === point.lat) {\n      const index = node.docIDs?.indexOf(docID)\n      if (index !== undefined && index > -1) {\n        // Remove the docID from the array\n        node.docIDs?.splice(index, 1)\n\n        if ((node.docIDs == null) || node.docIDs.length === 0) {\n          // If the node doesn't have any more docIDs, remove the node\n          if (parentNode != null) {\n            if (direction === 'left') {\n              parentNode.left = (node.left !== null) ? node.left : node.right\n            } else if (direction === 'right') {\n              parentNode.right = (node.right !== null) ? node.right : node.left\n            }\n          } else {\n            // If the node to be removed is the root\n            tree.root = ((node.left !== null) ? node.left : node.right) as Node\n          }\n        }\n\n        return\n      }\n    }\n\n    const axis = depth % K\n\n    parentNode = node as Nullable<Node>\n    // Compare by longitude\n    if (axis === 0) {\n      if (point.lon < node!.point.lon) {\n        node = node?.left\n        direction = 'left'\n      } else {\n        node = node?.right\n        direction = 'right'\n      }\n    // Compare by latitude\n    } else {\n      if (point.lat < node!.point.lat) {\n        node = node?.left\n        direction = 'left'\n      } else {\n        node = node?.right\n        direction = 'right'\n      }\n    }\n\n    depth++\n  }\n}\n\nexport function getDocIDsByCoordinates (tree: RootNode, point: Point): Nullable<InternalDocumentID[]> {\n  let node: Nullable<Node> = tree.root\n  let depth = 0\n\n  while (node !== null) {\n    if (node.point.lon === point.lon && node.point.lat === point.lat) {\n      // prettier-ignore\n      return node.docIDs ?? null\n    }\n\n    const axis = depth % K\n\n    // Compare by longitude\n    if (axis === 0) {\n      if (point.lon < node.point.lon) {\n        node = node.left as Nullable<Node>\n      } else {\n        node = node.right as Nullable<Node>\n      }\n    // Compare by latitude\n    } else {\n      if (point.lat < node.point.lat) {\n        node = node.left as Nullable<Node>\n      } else {\n        node = node.right as Nullable<Node>\n      }\n    }\n\n    depth++\n  }\n\n  return null\n}\n\nexport function searchByRadius (\n  node: Nullable<Node>,\n  center: Point,\n  radius: number,\n  inclusive = true,\n  sort: SortGeoPoints = 'asc',\n  highPrecision = false\n): GeoSearchResult[] {\n  const distanceFn = highPrecision ? vincentyDistance : haversineDistance\n  const stack: Array<{ node: Nullable<Node>, depth: number }> = [{ node, depth: 0 }]\n  const result: GeoSearchResult[] = []\n\n  while (stack.length > 0) {\n    const { node, depth } = stack.pop() as { node: Node, depth: number }\n    if (node === null) continue\n\n    const dist = distanceFn(center, node.point)\n\n    if (inclusive ? dist <= radius : dist > radius) {\n      result.push({ point: node.point, docIDs: node.docIDs ?? [] })\n    }\n\n    if (node.left != null) {\n      stack.push({ node: node.left, depth: depth + 1 })\n    }\n    if (node.right != null) {\n      stack.push({ node: node.right, depth: depth + 1 })\n    }\n  }\n\n  if (sort) {\n    result.sort((a, b) => {\n      const distA = distanceFn(center, a.point)\n      const distB = distanceFn(center, b.point)\n      return sort.toLowerCase() === 'asc' ? distA - distB : distB - distA\n    })\n  }\n\n  return result\n}\n\nexport function searchByPolygon (root: Nullable<Node>, polygon: Point[], inclusive = true, sort: SortGeoPoints = null, highPrecision = false): GeoSearchResult[] {\n  const stack: SearchTask[] = [{ node: root, depth: 0 }]\n  const result: GeoSearchResult[] = []\n\n  while (stack.length > 0) {\n    const task = stack.pop()\n    if ((task == null) || (task.node == null)) continue\n\n    const { node, depth } = task\n    const nextDepth = depth + 1\n\n    if (node.left != null) {\n      stack.push({ node: node.left, depth: nextDepth })\n    }\n\n    if (node.right != null) {\n      stack.push({ node: node.right, depth: nextDepth })\n    }\n\n    const isInsidePolygon = isPointInPolygon(polygon, node.point)\n\n    if (isInsidePolygon && inclusive) {\n      result.push({ point: node.point, docIDs: node.docIDs ?? [] })\n    } else if (!isInsidePolygon && !inclusive) {\n      result.push({ point: node.point, docIDs: node.docIDs ?? [] })\n    }\n  }\n\n  const centroid = calculatePolygonCentroid(polygon)\n\n  if (sort) {\n    const sortFn = highPrecision ? vincentyDistance : haversineDistance\n\n    result.sort((a, b) => {\n      const distA = sortFn(centroid, a.point)\n      const distB = sortFn(centroid, b.point)\n      return sort.toLowerCase() === 'asc' ? distA - distB : distB - distA\n    })\n  }\n\n  return result\n}\n\nfunction calculatePolygonCentroid (polygon: Point[]): Point {\n  let totalArea = 0\n  let centroidX = 0\n  let centroidY = 0\n\n  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n    const xi = polygon[i].lon\n    const yi = polygon[i].lat\n    const xj = polygon[j].lon\n    const yj = polygon[j].lat\n\n    const areaSegment = xi * yj - xj * yi\n    totalArea += areaSegment\n\n    centroidX += (xi + xj) * areaSegment\n    centroidY += (yi + yj) * areaSegment\n  }\n\n  totalArea /= 2\n\n  centroidX /= (6 * totalArea)\n  centroidY /= (6 * totalArea)\n\n  return { lon: centroidX, lat: centroidY }\n}\n\nfunction isPointInPolygon (polygon: Point[], point: Point): boolean {\n  let isInside = false\n  const x = point.lon; const y = point.lat\n  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n    const xi = polygon[i].lon; const yi = polygon[i].lat\n    const xj = polygon[j].lon; const yj = polygon[j].lat\n\n    const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)\n    if (intersect) isInside = !isInside\n  }\n\n  return isInside\n}\n\nfunction haversineDistance (coord1: Point, coord2: Point): number {\n  const P = Math.PI / 180\n  const lat1 = coord1.lat * (P)\n  const lat2 = coord2.lat * (P)\n  const deltaLat = (coord2.lat - coord1.lat) * (P)\n  const deltaLon = (coord2.lon - coord1.lon) * (P)\n\n  const a = Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) +\n            Math.cos(lat1) * Math.cos(lat2) *\n            Math.sin(deltaLon / 2) * Math.sin(deltaLon / 2)\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))\n\n  return EARTH_RADIUS * c\n}\n\nfunction vincentyDistance (coord1: Point, coord2: Point): number {\n  // Constants for WGS 84 ellipsoidal Earth model (https://epsg.org/ellipsoid_7030/WGS-84.html)\n  \n  // Semi-major axis of the Earth in meters\n  const a = 6378137\n\n  // Flattening of the ellipsoid\n  const f = 1 / 298.257223563\n\n  // Semi-minor axis\n  const b = (1 - f) * a\n\n  // Convert degrees to radians for calculations\n  const P = Math.PI / 180\n  const lat1 = coord1.lat * P\n  const lat2 = coord2.lat * P\n  const deltaLon = (coord2.lon - coord1.lon) * P\n\n  // Reduced latitudes - account for flattening by transforming from geodetic to auxiliary latitude\n  const U1 = Math.atan((1 - f) * Math.tan(lat1))\n  const U2 = Math.atan((1 - f) * Math.tan(lat2))\n\n  const sinU1 = Math.sin(U1)\n  const cosU1 = Math.cos(U1)\n  const sinU2 = Math.sin(U2)\n  const cosU2 = Math.cos(U2)\n\n  // Initial approximation for the longitude difference between the two points\n  let lambda = deltaLon\n  let prevLambda: number\n\n  // Limit the iterations to ensure we don't get stuck in an infinite loop\n  let iterationLimit = 1000\n  let sinAlpha: number\n  let cos2Alpha: number\n  let sinSigma: number\n  let cosSigma: number\n  let sigma: number\n\n  // Refine the value of lambda (longitude difference)\n  do {\n    const sinLambda = Math.sin(lambda)\n    const cosLambda = Math.cos(lambda)\n\n    // Compute the trigonometric values required for Vincenty formulae\n    sinSigma = Math.sqrt(\n      (cosU2 * sinLambda) * (cosU2 * sinLambda) +\n      (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda) *\n      (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda)\n    )\n\n    cosSigma = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda\n    sigma = Math.atan2(sinSigma, cosSigma)\n\n    // Angular separation between the two points and the equator\n    sinAlpha = cosU1 * cosU2 * sinLambda / sinSigma\n    cos2Alpha = 1 - sinAlpha * sinAlpha\n\n    const cos2SigmaM = cosSigma - 2 * sinU1 * sinU2 / cos2Alpha\n\n    // Compensation factor for the Earth's shape\n    const C = f / 16 * cos2Alpha * (4 + f * (4 - 3 * cos2Alpha))\n\n    // Store previous lambda to check for convergence\n    prevLambda = lambda\n\n    // Refine the estimate of lambda using the Vincenty formula\n    lambda = deltaLon + (1 - C) * f * sinAlpha *\n      (sigma + C * sinSigma *\n      (cos2SigmaM + C * cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM)))\n  } while (Math.abs(lambda - prevLambda) > 1e-12 && --iterationLimit > 0)\n\n  // Compute factors that depend on the shape of the Earth and angular distances\n  const u2 = cos2Alpha * (a * a - b * b) / (b * b)\n  const A = 1 + u2 / 16384 * (4096 + u2 * (-768 + u2 * (320 - 175 * u2)))\n  const B = u2 / 1024 * (256 + u2 * (-128 + u2 * (74 - 47 * u2)))\n\n  // Compute the correction factor for the ellipsoidal shape of the Earth\n  const deltaSigma = B * sinSigma *\n    (cosSigma - 2 * sinU1 * sinU2 / cos2Alpha + B / 4 *\n    (cosSigma * (-1 + 2 * sinSigma * sinSigma) -\n    B / 6 * sigma * (-3 + 4 * sinSigma * sinSigma) *\n    (-3 + 4 * sigma * sigma)))\n\n  // Final calculation of distance using Vincenty formula\n  const s = b * A * (sigma - deltaSigma)\n\n  return s\n}\n"],"names":["K","EARTH_RADIUS","create","root","insert","tree","point","docIDs","newNode","node","depth","lon","lat","newDocIDs","Array","from","Set","axis","left","right","contains","removeDocByID","docID","parentNode","direction","index","indexOf","undefined","splice","length","getDocIDsByCoordinates","searchByRadius","center","radius","inclusive","sort","highPrecision","distanceFn","vincentyDistance","haversineDistance","stack","result","pop","dist","push","a","b","distA","distB","toLowerCase","searchByPolygon","polygon","task","nextDepth","isInsidePolygon","isPointInPolygon","centroid","calculatePolygonCentroid","sortFn","totalArea","centroidX","centroidY","i","j","xi","yi","xj","yj","areaSegment","isInside","x","y","intersect","coord1","coord2","P","Math","PI","lat1","lat2","deltaLat","deltaLon","sin","cos","c","atan2","sqrt","f","U1","atan","tan","U2","sinU1","cosU1","sinU2","cosU2","lambda","prevLambda","iterationLimit","sinAlpha","cos2Alpha","sinSigma","cosSigma","sigma","sinLambda","cosLambda","cos2SigmaM","C","abs","u2","A","B","deltaSigma","s"],"mappings":"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"}