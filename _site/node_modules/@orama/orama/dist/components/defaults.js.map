{"version":3,"sources":["../../src/components/defaults.ts"],"sourcesContent":["import { createError } from '../errors.js'\nimport { Point } from '../trees/bkd.js'\nimport {\n  AnyDocument,\n  AnyOrama,\n  ArraySearchableType,\n  ElapsedTime,\n  ScalarSearchableType,\n  SearchableType,\n  TypedDocument,\n  Vector\n} from '../types.js'\nimport { formatNanoseconds, uniqueId } from '../utils.js'\n\nexport { getDocumentProperties } from '../utils.js'\n\nexport async function formatElapsedTime(n: bigint): Promise<ElapsedTime> {\n  return {\n    raw: Number(n),\n    formatted: await formatNanoseconds(n),\n  }\n}\n\nexport async function getDocumentIndexId(doc: AnyDocument): Promise<string> {\n  if (doc.id) {\n    if (typeof doc.id !== 'string') {\n      throw createError('DOCUMENT_ID_MUST_BE_STRING', typeof doc.id)\n    }\n\n    return doc.id\n  }\n\n  return await uniqueId()\n}\n\nexport async function validateSchema<T extends AnyOrama, ResultDocument extends TypedDocument<T>>(\n  doc: ResultDocument,\n  schema: T['schema'],\n): Promise<string | undefined> {\n  for (const [prop, type] of Object.entries(schema)) {\n    const value = doc[prop]\n\n    if (typeof value === 'undefined') {\n      continue\n    }\n\n    if (type === 'geopoint' && (typeof value === 'object' && typeof value.lon === 'number' && typeof value.lat === 'number')) {\n      continue\n    }\n\n    if (type === 'enum' && (typeof value === 'string' || typeof value === 'number')) {\n      continue\n    }\n    if (type === 'enum[]' && Array.isArray(value)) {\n      const valueLength = value.length\n      for (let i = 0; i < valueLength; i++) {\n        if (typeof value[i] !== 'string' && typeof value[i] !== 'number') {\n          return prop + '.' + i\n        }\n      }\n      continue\n    }\n\n    if (isVectorType(type)) {\n      const vectorSize = getVectorSize(type)\n      if (!Array.isArray(value) || value.length !== vectorSize) {\n        throw createError('INVALID_INPUT_VECTOR', prop, vectorSize, value.length)\n      }\n      continue\n    }\n\n    if (isArrayType(type)) {\n      if (!Array.isArray(value)) {\n        return prop\n      }\n      const expectedType = getInnerType(type)\n\n      const valueLength = value.length\n      for (let i = 0; i < valueLength; i++) {\n        if (typeof value[i] !== expectedType) {\n          return prop + '.' + i\n        }\n      }\n\n      continue\n    }\n\n    if (typeof type === 'object') {\n      if (!value || typeof value !== 'object') {\n        return prop\n      }\n\n      // using as ResultDocument is not exactly right but trying to be type-safe here is not useful\n      const subProp = await validateSchema(value as ResultDocument, type)\n      if (subProp) {\n        return prop + '.' + subProp\n      }\n      continue\n    }\n\n    if (typeof value !== type) {\n      return prop\n    }\n  }\n\n  return undefined\n}\n\nconst IS_ARRAY_TYPE: Record<SearchableType, boolean> = {\n  string: false,\n  number: false,\n  boolean: false,\n  enum: false,\n  geopoint: false,\n  'string[]': true,\n  'number[]': true,\n  'boolean[]': true,\n  'enum[]': true,\n}\n\nconst INNER_TYPE: Record<ArraySearchableType, ScalarSearchableType> = {\n  'string[]': 'string',\n  'number[]': 'number',\n  'boolean[]': 'boolean',\n  'enum[]': 'enum',\n}\n\nexport function isGeoPointType(type: unknown): type is Point {\n  return type === 'geopoint'\n}\n\nexport function isVectorType(type: unknown): type is Vector {\n  return typeof type === 'string' && /^vector\\[\\d+\\]$/.test(type)\n}\n\nexport function isArrayType(type: unknown): type is ArraySearchableType {\n  return typeof type === 'string' && IS_ARRAY_TYPE[type]\n}\n\nexport function getInnerType(type: ArraySearchableType): ScalarSearchableType {\n  return INNER_TYPE[type]\n}\n\nexport function getVectorSize(type: string): number {\n  const size = Number(type.slice(7, -1))\n\n  switch (true) {\n    case isNaN(size):\n      throw createError('INVALID_VECTOR_VALUE', type)\n    case size <= 0:\n      throw createError('INVALID_VECTOR_SIZE', type)\n    default:\n      return size\n  }\n}\n"],"names":["createError","formatNanoseconds","uniqueId","getDocumentProperties","formatElapsedTime","n","raw","Number","formatted","getDocumentIndexId","doc","id","validateSchema","schema","prop","type","Object","entries","value","lon","lat","Array","isArray","valueLength","length","i","isVectorType","vectorSize","getVectorSize","isArrayType","expectedType","getInnerType","subProp","undefined","IS_ARRAY_TYPE","string","number","boolean","enum","geopoint","INNER_TYPE","isGeoPointType","test","size","slice","isNaN"],"mappings":"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"}